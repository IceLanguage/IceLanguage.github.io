---
layout: page
title: 我对Astar，BFS，Dijstra的理解
category: 
    - blogs


---
## Dijstra

**原理**：从初始点开始，迭代检查周围的节点，并将合适的节点加入检查节点集，不断的向外扩展直到找到终点。

**算法复杂度**：时间O(n^2),空间O(n)

**优点**：能确保是最佳的路径

**缺点**：

## BFS

最佳优先搜索

**原理**：通过启发性函数H（n）（h(n)表示从结点n到目标点的启发式评估代价）选择最合适的节点迭代的加入检查节点集，直到到达终点

**算法复杂度**：时间O(nlgn),空间O(n)

**优点**：比Dijstra更快的找到合适的路径

**缺点**：是基于贪心策略的，不能确保是最短路径，如果出现障碍，可能会出现绕一段路的情况

## Astar

**原理**：它是Dijstra和BFS的结合，通过启发性函数f(n) = g(n) + h(n)选择合适的节点迭代的加入检查节点集，直到到达终点。g(n)表示从初始结点到任意结点n的代价，h(n)表示从结点n到目标点的启发式评估代价

**算法复杂度**：时间O(nlgn),空间O(n)

**优点**：能用于搜索最短路径，也能使用启发性函数，和BFS一样快

　启发式函数可以控制A*的行为：

-   一种极端情况，如果h(n)是0，则只有g(n)起作用，此时A*演变成Dijkstra算法，这保证能找到最短路径。
-   如果h(n)经常都比从n移动到目标的实际代价小（或者相等），则A*保证能找到一条最短路径。h(n)越小，A*扩展的结点越多，运行就得越慢。
-   如果h(n)精确地等于从n移动到目标的代价，则A*将会仅仅寻找最佳路径而不扩展别的任何结点，这会运行得非常快。尽管这不可能在所有情况下发生，你仍可以在一些特殊情况下让它们精确地相等（译者：指让h(n)精确地等于实际值）。只要提供完美的信息，A*会运行得很完美，认识这一点很好。
-   如果h(n)有时比从n移动到目标的实际代价高，则A*不能保证找到一条最短路径，但它运行得更快。
-   另一种极端情况，如果h(n)比g(n)大很多，则只有h(n)起作用，A*演变成BFS算法。

## 参考链接

https://blog.csdn.net/yulijunzj/article/details/18139085