---
layout: page
title: 关于gc算法
category: 
    - blogs


---

众所周知，c++是需要程序员手动管理内存的，然而手动释放内存很容易被程序员遗漏，从而导致资源浪费或内存泄露。为解决这个问题，垃圾回收器诞生了，代替程序员自动管理内存的释放。至于gc算法则是垃圾回收器清除垃圾的方法了。

本篇文章简单介绍一下各个gc算法的原理和优缺点

## GC Root

**GC roots are not objects in themselves but are instead references to objects.**

.NET中可以当作GC Root的对象有如下几种：

1、全局变量

2、静态变量

3、栈上的所有局部变量(JIT)

4、栈上传入的参数变量

5、寄存器中的变量

在Java中，可以当做GC Root的对象有以下几种：

1、虚拟机（JVM）栈中的引用的对象

2、方法区中的类静态属性引用的对象

3、方法区中的常量引用的对象（主要指声明为final的常量值）

4、本地方法栈中JNI的引用的对象

## 标记清除法

原理：从GC Root开始递归，对可能引用的对象进行标记，没有标记的作为垃圾被回收

步骤：遍历并标记对象->回收死亡对象，清除存活对象的标记

缺点：

1.清除阶段还需要对大量死亡对象进行扫描，死亡对象多的话会相当耗时

2.清理出来的内存空间不连续

## 标记整理法

原理：从GC Root开始递归，对可能引用的对象进行标记，之后移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收

步骤：遍历并标记对象->整理存活对象->回收

缺点：效率低

## 复制清除法

原理：遍历GC Root引用的对象，复制到另外的空间，并递归地对复制对象引用的对象进行复制，之后清除旧空间

步骤：递归复制->废弃旧空间

缺点：

1.复制开销大，存活对象多耗时大

2.浪费一半的内存

## 引用计数法

原理：为每个对象保存引用计数，引用增减时更新计数

步骤：不需要扫描，对计数0的对象进行垃圾回收

缺点：

1.无法释放循环引用的对象

### 循环引用

```c#
A a = new A();
B b = new B();
C c = new C();
A.b = b;
B.c = c;
C.a = a;
```

2.引用计数不能遗漏

3.不适合并行处理

## 分代搜集法

原理：对分配时间短的对象进行清理

比如Net，将内存中的对象分为了三代，每执行N次0代的回收，才会执行一次1代的回收，而每执行N次1代的回收，才会执行一次2代的回收。当某个对象实例在GC执行时被发现仍然在被使用，它将被移动到下一个代中上。

而在mono 中是分2代

## 各平台GC算法

关于Mono ，集成的是开源项目BOEHM ，BOEHM算法采用标记清除法 

## 参考资料

[[《代码的未来》读书笔记：内存管理与GC那点事儿](https://www.cnblogs.com/edisonchou/p/4858501.html)]

[[垃圾回收机制GC知识再总结兼谈如何用好GC](https://www.cnblogs.com/jeffwongishandsome/p/talk-about-GC-and-how-to-use-GC-better.html)]