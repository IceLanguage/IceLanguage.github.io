---
layout: page
title: c++复习-基本内置类型
category: 
    - blogs
---

## 无符号数和符号数

无符号数计算时，表达式如果有符号数，将自动转换为符号数。
无符号数不存在负数，-1=2*32-1

## 字符串的前后缀

前缀|含义
-|-
u| unicode16字符
U| unicode32字符
L|宽字符
u8|utf-8


后缀|含义
-|-
u或U| 无符号类型
l或L|至少为long
ll或LL| 至少为long long
f或F |float类型

## 变量声明和定义的关系

extern一个变量且没有初始化 为声明
否则为定义(编译器会自动初始化变量）

## 引用

&d引用只是为对象另起了一个名字，引用必须初始化。
引用本身没有地址，不是对象，不能做引用的引用

## 指针

指针本身就是一个对象，允许指针之间的拷贝和赋值，也可以在其生命周期指向不同的对象。而引用不行
指针无需在定义时赋值。
```
int* p= &i;
```
```
int &j = i;  //&符号紧随类型名出现，它是声明的一部分，j是一个引用。  
int *p;     //*符号紧随类型名出现，它是声明的一部分，p是一个指针。  
p = &i;    //&符号出现在表达式之中，是一个取地址符号。  
*p = i;    //*符号出现在表达式之中，是一个解引用符  
int &j2 = *p;   //&是声明的一部分，*是解引用符。  
```
```
int a = 0, b = 1;  
int *p1 = &a, *p2 = p1;  
p1 = &b;  //改变了指针的值  
*p1 = b;   //改变指针所指对象的值  
```

## const

常量必须初始化
### 引用和const
```
int i=4;
const int &j=i;//常量引用
```
规定的常量引用不能用以修改引用对象的值，但引用对象的其他引用可以修改

### 指针和const
```
int i=0;
const int *p=0;//必须指向常量的指针
int *const p=&i;//指针本身是个常量
```

### 顶层const

顶层const是指指针本身是一个常量
底层const是指指针所指对象是一个常量
顶层const:指的是本身不可以被改变。
底层const:指的是自身所指对象不可以被改变。
用于声明引用的const都是底层const
```
const int* const p3=p;//靠右的const是顶层const；靠左的是底层const
```

## constexpr和常量表达式

常量表达式是值不会改变并且在编译过程中就能得到计算结果的表达式

constexpr修饰的变量一定是个常量，必须初始化

自定义类，IO库，string不属于字面值类型，不能定义为constexpr

constexpr如果修饰一个指针，只对指针有效，和指针所指对象无关

## auto 类型

当我们不知道变量表达式的类型时，可以使用auto让编译器为我们决定表达式的类型
auto会自动忽略掉顶层const，而底层const会被保留。
auto定义的变量必须有初始值。

## decltype

decltype：希望从表达式的类型推断出想要定义的变量的类型，该操作返回操作数的类型。
decltype(())双层括号表示引用（注意引用必须初始化）

赋值的表达式语句本身是一种引用：
```
int a=3,b=4;
decltype((b==a)) d=a;// int& d =a;

```

## auto和decltype区别
主要的区别有两点：

1：如果使用引用类型，auto会识别为其所指对象的类型，decltype则会识别为引用的类型。

2：decltype(())双括号的差别。

```
int i = 0, &r = i;  
// same  
auto a = i;  
decltype(i) b = i;  
// different  
auto c = r;  
decltype(r) d = i;  
```